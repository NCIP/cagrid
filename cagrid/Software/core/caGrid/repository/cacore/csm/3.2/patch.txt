Index: src/gov/nih/nci/security/authentication/LockoutManager.java
===================================================================
--- src/gov/nih/nci/security/authentication/LockoutManager.java	(revision 3554)
+++ src/gov/nih/nci/security/authentication/LockoutManager.java	(working copy)
@@ -1,28 +1,36 @@
 package gov.nih.nci.security.authentication;
 
+import gov.nih.nci.security.constants.Constants;
+
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Timer;
 import java.util.TimerTask;
 
+import org.apache.log4j.Logger;
+
 public class LockoutManager
 {
 
+    private static Logger LOG = Logger.getLogger(LockoutManager.class);
+    
 	private static HashMap lockoutCache = null;
 	private static LockoutManager lockoutManager = null;
 	static Timer cleanupTimer = new Timer();
 
 	private long lockoutTime = 1800000;
 	private long allowedLoginTime;
+	private long lockoutPurgeFrequency;
 	private int allowedAttempts;
 	private boolean disableLockoutManager;
-	private long delayTime;
 	
 	private class CleanupTask extends TimerTask
 	{
 		public void run()
 		{
+		    LOG.debug("Running lockout cleanup");
+		    LOG.debug("\tLockout time: " + lockoutTime);
 			//Collection<String> userIds = lockoutCache.keySet(); - Removed to support java1.4 osr
 			Collection userIds = (Collection)lockoutCache.keySet();
 			Iterator iter = userIds.iterator();
@@ -30,9 +38,13 @@
 			while (iter.hasNext())
 			{
 				String userId = (String) iter.next();
+				LOG.debug("Testing user " + userId + " for unlock");
 				LockoutInfo lockoutInfo = (LockoutInfo)lockoutCache.get(userId);
-				if (delayTime < (System.currentTimeMillis() - lockoutInfo.getFirstLoginTime()))
+				long delta = System.currentTimeMillis() - lockoutInfo.getFirstLoginTime();
+				LOG.debug("\tUser has been locked for " + delta);
+				if (lockoutTime < delta)
 				{
+				    LOG.debug("Removing lock for " + userId);
 					lockoutCache.remove(userId);
 				}
 			}
@@ -77,7 +89,7 @@
 		
 	}
 
-	private LockoutManager(String lockoutTime, String allowedLoginTime, String allowedAttempts)
+	private LockoutManager(String lockoutTime, String allowedLoginTime, String allowedAttempts, String lockoutPurgeFrequency)
 	{
 		lockoutManager = new LockoutManager();
 		//lockoutCache = new HashMap();
@@ -90,9 +102,9 @@
 			//this.allowedLoginTime = new Long(allowedLoginTime); - Removed to support java1.4 osr
 			this.allowedLoginTime = new Long(allowedLoginTime).longValue();
 			this.allowedAttempts = Integer.parseInt(allowedAttempts);
+			this.lockoutPurgeFrequency = new Long(lockoutPurgeFrequency).longValue();
 			this.disableLockoutManager = false;
-			this.delayTime = this.lockoutTime + this.allowedLoginTime;
-			cleanupTimer.schedule(new CleanupTask(), delayTime, delayTime);
+			cleanupTimer.schedule(new CleanupTask(), this.lockoutTime, this.lockoutPurgeFrequency);
 		}
 
 	}
@@ -107,16 +119,25 @@
 	{
 		if (null == lockoutManager)
 		{
-			lockoutManager = new LockoutManager(lockoutTime, allowedLoginTime, allowedAttempts);
+			lockoutManager = new LockoutManager(lockoutTime, allowedLoginTime, allowedAttempts, Constants.LOCKOUT_PURGE_FREQUENCY);
 		}
 	}
 	
+	
+	public static void initialize(String lockoutTime, String allowedLoginTime, String allowedAttempts, String lockoutPurgeFrequency)
+    {
+        if (null == lockoutManager)
+        {
+            lockoutManager = new LockoutManager(lockoutTime, allowedLoginTime, allowedAttempts, lockoutPurgeFrequency);
+        }
+    }
+	
 	public static LockoutManager getInstance()
 	{
 		if (null == lockoutManager)
 		{
 			// Initialize with the following defaults
-			lockoutManager = new LockoutManager("1800000", "60000", "3");
+			lockoutManager = new LockoutManager("1800000", "60000", "3", Constants.LOCKOUT_PURGE_FREQUENCY);
 		}
 		return lockoutManager;
 	}	
Index: src/gov/nih/nci/security/constants/Constants.java
===================================================================
--- src/gov/nih/nci/security/constants/Constants.java	(revision 3554)
+++ src/gov/nih/nci/security/constants/Constants.java	(working copy)
@@ -138,5 +138,6 @@
 	public static final String LOCKOUT_TIME = "1800000";
 	public static final String ALLOWED_LOGIN_TIME = "60000";
 	public static final String ALLOWED_ATTEMPTS = "3";
+	public static final String LOCKOUT_PURGE_FREQUENCY = "60000";
 
 }
Index: src/test/gov/nih/nci/security/LockoutManagerTest.java
===================================================================
--- src/test/gov/nih/nci/security/LockoutManagerTest.java	(revision 0)
+++ src/test/gov/nih/nci/security/LockoutManagerTest.java	(revision 0)
@@ -0,0 +1,56 @@
+package test.gov.nih.nci.security;
+
+import gov.nih.nci.security.authentication.LockoutManager;
+import junit.framework.TestCase;
+import junit.framework.TestResult;
+import junit.framework.TestSuite;
+import junit.textui.TestRunner;
+
+public class LockoutManagerTest extends TestCase {
+    
+    public static final String LOCKOUT_TIME_MS = "5000"; // 5 sec
+    public static final String ALLOWED_LOGIN_TIME_MS = "3000"; // 3 sec
+    public static final String LOCKOUT_PURGE_TIME = "1000"; // purge every 1 sec
+    public static final String MAX_ATTEMPTS = "3"; // 3 logins == locked out
+    
+    private LockoutManager lockoutManager = null;
+    
+    public LockoutManagerTest(String name) {
+        super(name);
+        // lockout manager is a singleton with multiple ways it can be instantiated
+        // .... yeah, I know....
+        LockoutManager.initialize(LOCKOUT_TIME_MS, ALLOWED_LOGIN_TIME_MS, MAX_ATTEMPTS, LOCKOUT_PURGE_TIME);
+        lockoutManager = LockoutManager.getInstance();
+    }
+    
+    
+    public void testLockouts() {
+        String userId = "Testing_User_" + System.currentTimeMillis();
+        assertFalse("User was locked out before we did anything!", lockoutManager.isUserLockedOut(userId));
+        for (int i = 0; i < Integer.valueOf(MAX_ATTEMPTS).intValue() - 1; i++) {
+            lockoutManager.setFailedAttempt(userId);
+            assertFalse("User was locked out on attempt number " + i + ", should have been " + MAX_ATTEMPTS, 
+                lockoutManager.isUserLockedOut(userId));
+        }
+        lockoutManager.setFailedAttempt(userId);
+        assertTrue("User was not locked out after " + MAX_ATTEMPTS + " attempts!", lockoutManager.isUserLockedOut(userId));
+        long sleepTime = Long.parseLong(LOCKOUT_TIME_MS) + (2 * Long.parseLong(LOCKOUT_PURGE_TIME));
+        try {
+            System.out.println("Sleeping " + sleepTime + " ms to wait for unlock");
+            Thread.sleep(sleepTime);
+        } catch (InterruptedException ex) {
+            ex.printStackTrace();
+            fail("Can't sleep; clown will eat me");
+        }
+        boolean isLocked = lockoutManager.isUserLockedOut(userId);
+        assertFalse("After sleeping " + sleepTime + " ms, user was still locked out!", isLocked);
+    }
+    
+    
+    public static void main(String[] args) {
+        TestRunner runner = new TestRunner();
+        TestResult result = runner.doRun(new TestSuite(LockoutManagerTest.class));
+        System.exit(result.errorCount() + result.failureCount());
+    }
+
+}
